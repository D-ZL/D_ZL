# Go

## 导入

**关键字**

`import`

## 函数

**关键字**

`func`

`defer` 语句会将函数推迟到外层函数返回之后执行。

> 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。
> 推迟的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。

**函数值**

函数也是值。它们可以像其它值一样传递。

函数值可以用作函数的参数或返回值。

**函数的闭包**

Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。

## 类型

- `bool`
- `string`
- `int` `int8` `int16` `int32` `int64`
- `uint` `uint8` `uint16` `uint32` `uint64` `uintptr`
- `byte` - `uint8` 的别名
- `rune` - `int32` 的别名，代表一个 Unicode 码
- `float32` `float64`
- `complex64` `complex128`

**类型转换**

`T(v)` 将值 `v` 转换为类型 `T`

## 常量

**关键字**

`const`

```go
const identifier [type] = value
```

**值**

- `string`
- `bool`
- 数值型 (`int` `float` 复数)

## 变量

**关键字**

`var`

```go
var identifier type
var identifier [type] = value
// 局部变量
identifier :- value
```

> 可以通过 `&` 来获取变量的内存地址
> 空白标识符 `_` 抛弃值

## init 函数

`init` 函数是非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。
每一个源文件都可以包含一个或多个 init 函数。

## 运算符

### 逻辑运算

**一元运算符**

- `!` 非运算符

**二元运算符**

- `==` 相等运算符
- `!=` 不等运算符
- `&&` 和运算符
- `||` 或运算符

### 位运算

**一元运算符**

- `^` 按位补足
- `<<` 位左移
- `>>` 位右移

**二元运算符**

- `&` 按位与
- `|` 按位或
- `^` 按位异或

## 流程控制语句

### `for`

Go 中只有一个 `for` 循环

```
for i := 0; i < 10; i++ {
    // code
}
```

初始化语句和后置语句是可选的
> 可省略 `;` 相当于 C 中的 `while`

```
sum := 0;
for ; sum < 1000; {
    sum += sum
}
for sum < 1000 {
    sum += sum
}
```

死循环
> 省略循环条件

```
for {
    // code
}
```

### `if`

```
if 1 > 0 {
    // code
}

// 变量域只在 if 中
if v := 1; v < 10 {
    fmt.Println(i)
} else {
    fmt.Println(i)
}
```

### `switch`
 
`switch` 的 `case` 语句从上到下顺次执行，直到匹配成功时停止

> 自动提供 `case` 后的 `break`
> 同时测试多个可能符合条件的值，使用逗号分割它们

没有条件的 `switch` 同 `switch true` 一样。

```
switch i := 0; i {
    case 0:
    // code
    case 1:
    // code
    default:
    // code
}
```

## 指针

指针保存了值的内存地址

类型 `*T` 是指向 T 类型值的指针。其零值为 `nil` 

`&` 操作符会生成一个指向其操作数的指针

`*` 操作符表示指针指向的底层值

## 结构体

一个结构体（struct）就是一个字段的集合

结构体字段使用点号来访问

结构体字段可以通过结构体指针来访问

> `(*p).X` 访问其字段 X 可使用隐式间接引用 `p.X`

使用 `Name:` 语法可以仅列出部分字段

特殊的前缀 `&` 返回一个指向结构体的指针


```
type Test struct {
    X, Y int
}

var (
    v = Test{X:1}    // {1, 0}
    p  = &Test{1, 2} // &{1, 2}
)
```

## 数组

类型 `[n]T` 表示拥有 n 个 T 类型的值的数组。

`var a [10]int`

### 切片

类型 `[]T` 表示一个元素类型为 T 的切片

切片的零值是 `nil` 。

`nil` 切片的长度和容量为 0 且没有底层数组。

`a[low : high]`

> 它会选择一个半开区间，包括第一个元素，但排除最后一个元素

**切片就像数组的引用**

切片并不存储任何数据， 它只是描述了底层数组中的一段。

更改切片的元素会修改其底层数组中对应的元素。

与它共享底层数组的切片都会观测到这些修改。

**切片文法**

`[]bool{}`

**切片的默认行为**

切片下界的默认值为 0 ，上界则是该切片的长度。

**切片的长度与容量**

`len()` 切片的长度就是它所包含的元素个数。

`cap()` 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。

**用 make 创建切片**

`make([]T, len, cap)`

**向切片追加元素**

`append([]T, T ...) []T`

> 自动分配更大的数组
> 每次增加以 2 的次方

**Range**

`for` 循环的 `range` 形式可遍历切片或映射

当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本

> 可以将下标或值赋予 `_` 来忽略它

> 若你只需要索引，去掉 `, value` 的部分即可

```
for k, v := range []T {
    // Code
}

// 只要值
for _, v := range []T {
    // Code
}

// 只要索引
for k := range []T {
    // Code
}
```

## 映射

`map[T]T`

映射将键映射到值

映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键

`make` 函数会返回给定类型的映射，并将其初始化备用

> 若顶级类型只是一个类型名，你可以在文法的元素中省略它

**修改**

`m[key] = elem`

**获取**

`elem = m[key]`

**删除**

`delete(m, key)`

**通过双赋值检测某个键是否存在**

```
elem, ok = m[key]
// 未声明
elem, ok := m[key]
```

若 `key` 在 `m` 中， `ok` 为 `true` ；否则， `ok` 为 `false` 

若 `key` 不在映射中，那么 `elem` 是该映射元素类型的零值

同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值

## 方法

Go 没有类

方法就是一类带特殊的**接收者**参数的函数。

方法接收者在它自己的参数列表内，位于 `func` 关键字和方法名之间。

```go
func (v T) F T {
    // code
}
```

**方法即函数**

> 方法只是个带接收者参数的函数。

只能为在同一包内定义的类型的接收者声明方法， 而不能为其它包内定义的类型的接收者声明方法。

> 接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法

### 指针接收者

对于某类型 `T` ，接收者的类型可以用 `*T` 的文法。 （此外， `T` 不能是像 `*int` 这样的指针。）

指针接收者的方法可以修改接收者指向的值。 由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。

## 接口

**接口类型**是由一组方法签名定义的集合。

接口类型的值可以保存任何实现了这些方法的值。
