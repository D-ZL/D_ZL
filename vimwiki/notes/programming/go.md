# Go

## 导入

**关键字**

`import`

## 函数

**关键字**

`func`

`defer` 语句会将函数推迟到外层函数返回之后执行。

> 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。
> 推迟的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。

**函数值**

函数也是值。它们可以像其它值一样传递。

函数值可以用作函数的参数或返回值。

**函数的闭包**

Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。

## 类型

- `bool`
- `string`
- `int` `int8` `int16` `int32` `int64`
- `uint` `uint8` `uint16` `uint32` `uint64` `uintptr`
- `byte` - `uint8` 的别名
- `rune` - `int32` 的别名，代表一个 Unicode 码
- `float32` `float64`
- `complex64` `complex128`

**类型转换**

`T(v)` 将值 `v` 转换为类型 `T`

## 常量

**关键字**

`const`

```go
const identifier [type] = value
```

**值**

- `string`
- `bool`
- 数值型 (`int` `float` 复数)

## 变量

**关键字**

`var`

```go
var identifier type
var identifier [type] = value
// 局部变量
identifier :- value
```

> 可以通过 `&` 来获取变量的内存地址
> 空白标识符 `_` 抛弃值

## init 函数

`init` 函数是非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。
每一个源文件都可以包含一个或多个 init 函数。

## 运算符

### 逻辑运算

**一元运算符**

- `!` 非运算符

**二元运算符**

- `==` 相等运算符
- `!=` 不等运算符
- `&&` 和运算符
- `||` 或运算符

### 位运算

**一元运算符**

- `^` 按位补足
- `<<` 位左移
- `>>` 位右移

**二元运算符**

- `&` 按位与
- `|` 按位或
- `^` 按位异或

## 流程控制语句

### `for`

Go 中只有一个 `for` 循环

```go
for i := 0; i < 10; i++ {
    // code
}
```

初始化语句和后置语句是可选的
> 可省略 `;` 相当于 C 中的 `while`

```go
sum := 0;
for ; sum < 1000; {
    sum += sum
}
for sum < 1000 {
    sum += sum
}
```

死循环
> 省略循环条件

```go
for {
    // code
}
```

### `if`

```go
if 1 > 0 {
    // code
}

// 变量域只在 if 中
if v := 1; v < 10 {
    fmt.Println(i)
} else {
    fmt.Println(i)
}
```

### `switch`
 
`switch` 的 `case` 语句从上到下顺次执行，直到匹配成功时停止

> 自动提供 `case` 后的 `break`
> 同时测试多个可能符合条件的值，使用逗号分割它们

没有条件的 `switch` 同 `switch true` 一样。

```go
switch i := 0; i {
    case 0:
    // code
    case 1:
    // code
    default:
    // code
}
```

## 指针

指针保存了值的内存地址

类型 `*T` 是指向 T 类型值的指针。其零值为 `nil` 

`&` 操作符会生成一个指向其操作数的指针

`*` 操作符表示指针指向的底层值

## 结构体

一个结构体（struct）就是一个字段的集合

结构体字段使用点号来访问

结构体字段可以通过结构体指针来访问

> `(*p).X` 访问其字段 X 可使用隐式间接引用 `p.X`

使用 `Name:` 语法可以仅列出部分字段

特殊的前缀 `&` 返回一个指向结构体的指针


```go
type Test struct {
    X, Y int
}

var (
    v = Test{X:1}    // {1, 0}
    p  = &Test{1, 2} // &{1, 2}
)
```

## 数组

类型 `[n]T` 表示拥有 n 个 T 类型的值的数组。

`var a [10]int`

### 切片

类型 `[]T` 表示一个元素类型为 T 的切片

切片的零值是 `nil` 。

`nil` 切片的长度和容量为 0 且没有底层数组。

`a[low : high]`

> 它会选择一个半开区间，包括第一个元素，但排除最后一个元素

**切片就像数组的引用**

切片并不存储任何数据， 它只是描述了底层数组中的一段。

更改切片的元素会修改其底层数组中对应的元素。

与它共享底层数组的切片都会观测到这些修改。

**切片文法**

`[]bool{}`

**切片的默认行为**

切片下界的默认值为 0 ，上界则是该切片的长度。

**切片的长度与容量**

`len()` 切片的长度就是它所包含的元素个数。

`cap()` 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。

**用 make 创建切片**

`make([]T, len, cap)`

**向切片追加元素**

`append([]T, T ...) []T`

> 自动分配更大的数组
> 每次增加以 2 的次方

**Range**

`for` 循环的 `range` 形式可遍历切片或映射

当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本

> 可以将下标或值赋予 `_` 来忽略它

> 若你只需要索引，去掉 `, value` 的部分即可

```go
for k, v := range []T {
    // Code
}

// 只要值
for _, v := range []T {
    // Code
}

// 只要索引
for k := range []T {
    // Code
}
```

## 映射

`map[T]T`

映射将键映射到值

映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键

`make` 函数会返回给定类型的映射，并将其初始化备用

> 若顶级类型只是一个类型名，你可以在文法的元素中省略它

**修改**

`m[key] = elem`

**获取**

`elem = m[key]`

**删除**

`delete(m, key)`

**通过双赋值检测某个键是否存在**

```go
elem, ok = m[key]
// 未声明
elem, ok := m[key]
```

若 `key` 在 `m` 中， `ok` 为 `true` ；否则， `ok` 为 `false` 

若 `key` 不在映射中，那么 `elem` 是该映射元素类型的零值

同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值

## 方法

Go 没有类

方法就是一类带特殊的**接收者**参数的函数。

方法接收者在它自己的参数列表内，位于 `func` 关键字和方法名之间。

```go
func (v T) F T {
    // code
}
```

**方法即函数**

> 方法只是个带接收者参数的函数。

只能为在同一包内定义的类型的接收者声明方法， 而不能为其它包内定义的类型的接收者声明方法。

> 接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法

### 指针接收者

对于某类型 `T` ，接收者的类型可以用 `*T` 的文法。 （此外， `T` 不能是像 `*int` 这样的指针。）

指针接收者的方法可以修改接收者指向的值。 由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。

## 接口

**接口类型**是由一组方法签名定义的集合。

接口类型的值可以保存任何实现了这些方法的值。

### 接口与隐式实现

类型通过实现一个接口的所有方法来实现该接口。 既然无需专门显式声明，也就没有 `implements` 关键字。

隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。

因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。

### 接口值

接口值可以看做包含值和具体类型的元组：

```go
(value, type)
```

接口值保存了一个具体底层类型的具体值。

接口值调用方法时会执行其底层类型的同名方法。

### 底层值为 `nil` 的接口值

即便接口内的具体值为 `nil`，方法仍然会被 `nil` 接收者调用。

### `nil` 接口值

`nil` 接口值既不保存值也不保存具体类型。

为 `nil` 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个**具体**方法的类型。

### 空接口

指定了零个方法的接口值被称为**空接口**：

```go
interface{}
```

空接口可保存任何类型的值

> 因为每个类型都至少实现了零个方法

空接口被用来处理未知类型的值

> 例如，`fmt.Print` 可接受类型为 `interface{}` 的任意数量的参数

### 类型断言

**类型断言**提供了访问接口值底层具体值的方式。

```go
t := i.(T)
```

该语句断言接口值 `i` 保存了具体类型 `T`，并将其底层类型为 `T` 的值赋予变量 `t`。

若 `i` 并未保存 `T` 类型的值，该语句就会触发一个恐慌。

为了判断一个接口值是否保存了一个特定的类型， 类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。

```go
t, ok := i.(T)
```

若 `i` 保存了一个 `T`，那么 `t` 将会是其底层值，而 `ok` 为 `true`。

否则， `ok` 将为 `false` 而 `t` 将为 `T` 类型的零值，程序并不会产生恐慌。

### 类型选择

**类型选择**是一种按顺序从几个类型断言中选择分支的结构

类型选择与一般的 `switch` 语句相似，不过类型选择中的 `case` 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。

```go
switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
```

类型选择中的声明与类型断言 `i.(T)` 的语法相同，只是具体类型 `T` 被替换成了关键字 `type`。

### `Stringer`

`fmt` 包中定义的 `Stringer` 是最普遍的接口之一。

```go
type Stringer interface {
    String() string
}
```

`Stringer` 是一个可以用字符串描述自己的类型。很多包都通过此接口来打印值。 

### `error`

Go 程序使用 `error` 值来表示错误状态。

```go
type error interface {
    Error() string
}
```

通常函数会返回一个 `error` 值，调用的它的代码应当判断这个错误是否等于 `nil` 来进行错误处理。

`error` 为 `nil` 时表示成功；非 `nil` 的 `error` 表示失败。

### `Reader`

`io` 包指定了 `io.Reader` 接口，它表示从数据流的末尾进行读取。

Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。

`io.Reader` 接口有一个 `Read` 方法：

```go
func (T) Read(b []byte) (n int, err error)
```

`Read` 用数据填充给定的字节切片并返回填充的字节数和错误值。 在遇到数据流的结尾时，它会返回一个 `io.EOF` 错误。

### image

`image` 包定义了 `Image` 接口：

```go
package image

type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}
```

> **注意** ：`Bounds` 方法的返回值 `Rectangle` 实际上是一个 `image.Rectangle`，它在 `image` 包中声明。

`color.Color` 和 `color.Model` 类型也是接口，但是通常因为直接使用预定义的实现 `image.RGBA` 和 `image.RGBAModel` 而被忽视了。这些接口和类型由 `image/color` 包定义。

## 并发

###  Go程

**Go程**是由 Go 运行时管理的轻量级线程

```go
go f(x, y, z)
```

### 信道

**信道**是带有类型的管道，你可以通过它用信道操作符 `<-` 来发送或者接收值。

和映射与切片一样，信道在使用前必须创建：

```go
ch := make(chan int)

ch <- v    // 将 v 发送至信道 ch。
v := <-ch  // 从 ch 接收值并赋予 v。
```

> **箭头**就是数据流的方向

默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go程可以在没有显式的锁或静态变量的情况下进行同步。

信道可以是**带缓冲的**。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道：

```go
ch := make(chan int, 100)
```

仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。

发送者可通过 `close` 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完

```go
v, ok := <-ch
```

之后 `ok` 会被设置为 `false` 。

循环 `for i := range c` 会不断从信道接收值，直到它被关闭。

> **注意**：只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。

> **还要注意**：信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有值需要发送的时候才有必要关闭，例如终止一个 `range` 循环。

### select 语句

`select` 语句使一个 Go 程可以等待多个通信操作。

`select` 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。

当 `select` 中的其它分支都没有准备好时，`default` 分支就会执行。

为了在尝试发送或者接收时不发生阻塞，可使用 `default` 分支：

```go
select {
case i := <-c:
    // 使用 i
default:
    // 从 c 中接收会阻塞时执行
}
```
