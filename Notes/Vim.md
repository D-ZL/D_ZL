# Vim

## 删除空行

`:g/^$/d`

> `:[range]g[lobal]/{pattern}/[cmd]`
>
> 在`[range]`界定的匹配模式`{pattern}`的文本行上执行Ex命令`[cmd]`
>
> `:[range]g[lobal]!/{pattern}/[cmd]`
>
> 在`[range]`界定的不匹配模式`{pattern}`的文本行上执行Ex命令`[cmd]`
>
> `:[range]v[lobal]/{pattern}/[cmd]`
>
> 等同于 `:g!`

## 删除重复行

```
:sort
:sor ur /^/
```

> `:[range]sor[t][!] [i][u][r][n][x][o] [/{pattern}/]`
>
> 给` [range]` 里的行排序。如果没有给出行范围，给所有行排序。
>
> 带 `[!]` 则反向排序。
>
> 带 `[i]` 则忽略大小写。
>
> 带 `[n]` 则排序基于每行的第一个十进制数 (在 `{pattern}` 匹
> 配之后或之内)。
> 数值包含前导的 '-'。
>
> 带 `[x]` 则排序基于每行的第一个十六进制数 (在 `{pattern}`
> 匹配之后或之内)。忽略引导的 "0x" 或 "0X"。
> 数值包含前导的 '-'。
>
> 带 `[o]` 则排序基于每行的第一个八进制数 (在 `{pattern}` 匹
> 配之后或之内)。
>
> 带 `[u]` 则只保留完全相同的行的第一行 (如果带 `[i]`，忽略
> 大小写的区别)。
> 没有这个标志位，完全相同的行的序列会按照它们原来的顺序
> 被保留下来。
> 注意 引导和拖尾的空白差异会导致不相同的行。
>
> 如果指定 `/{pattern}/` 并且没有 `[r]` 标志位，跳过匹配
> `{pattern}` 的文本，使得排序在匹配之后的内容上进行。
> 除了斜杠以外，任何非字母的字符都可以。
> 例如，要按第二个逗号分隔的字段排序:
> `:sort /[^,]*,/`
> 按虚拟第 10 列的文本排序 (从而忽略制表和空格的区别): 
> `:sort /.*\%10v/`
> 按每行的第一个数值排序，不管它前面有什么: 
> `:sort /.\{-}\ze\d/`
> (说明: ".\{-}" 匹配任何文本，"\ze" 设置匹配结束位置，
> \d 匹配单个数位。)
> 带 `[r]` 则排序在匹配 `{pattern}` 的文本上进行，而不是如上
> 所述的用它之后的文本。
> 例如，要按每行的前三个字母排序且只看这三个字母: 
> `:sort /\a\a\a/ r`
>
> 如果使用 `{pattern}`，不匹配 `{pattern}` 的行按照它们原来
> 的顺序被保留，但和匹配 `{pattern}` 的行分开。如果反向排
> 序，它们会以反向顺序出现，并在排序好的行之后。否则它们
> 会以原有顺序出现，在排序好的行之前。
>
> 如果 `{pattern}` 为空 (例如指定 //)，则使用最近使用的搜
> 索模式。这样你可以先试好模式，然后在执行。
>

## 基本计算器

在插入模式下，你可以使用 `Ctrl + r` 键然后输出 `=`，再输入一个简单的算式。按 `Enter` 键，计算结果会插入到文件中。

## 查找重复的连续单词

```
/\(\<\w\+\>\)\_s*\1
```

## 忘记用 root 方式打开文件时文件保存

```
:w !sudo tee %
```

## 实时 ROT13 加密文本

```
ggVGg?
```

## 文件加密解密

```
"加密
:X
:wq

"解密
:set key=
:wq
```

## 文件对比

```
:vert[ical] diffs[plit] {filename} "文件对比
[c "跳转到上一处差异文件的位置
]c "跳转到下一处差异文件的位置
```

